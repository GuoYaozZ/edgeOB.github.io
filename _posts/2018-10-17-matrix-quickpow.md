---
layout:     post
title:      "快速幂与矩阵快速幂"
subtitle:   "顺带加进去了矩阵构造/其实没什么东西（逃"
date:       2018-10-17 01:00:00
author:     "programfiles"
header-img: "img/in-post/matrix.jpg"
tags:
    - 数学
---
# 快速幂
可以将O(n)时间复杂度降低至O(logn)，原理及代码如下
```cpp
5^9 = 5*5^8 = 5*((5^4)^2) = 5*(5^4)*(5^4)
5^4 = ((5^2)^2) = (5^2)*(5^2)
5^2 = 5*5
```
```cpp
int qpow(int base, int n){
    int ans = 1;
    while(n){
        if(n&1) ans*=base;
        base = base * base;
        n/=2;
    }
    return ans;
}
```
# 矩阵快速幂
同理用于快速求一个矩阵的n次方
```cpp
struct Matrix{
    int a[maxn][maxn];
    void init(){
        memset(a, 0, sizeof(a));
        for(int i=0;i<maxn;++i){
            a[i][i] = 1;
        }
    }
};

Matrix mul(Matrix a, Matrix b){
    Matrix ans;
    for(int i=0;i<maxn;++i){
        for(int j=0;j<maxn;++j){
            ans.a[i][j] = 0;
            for(int k=0;k<maxn;++k){
                ans.a[i][j] += a.a[i][k] * b.a[k][j];
                ans.a[i][j] %= mod; 
            }
        }
    } 
    return ans;
}

Matrix qpow(Matrix a, int n){
    Matrix ans;
    ans.init();
    while(n){
        if(n&1) ans = mul(ans, a);
        a = mul(a, a);
        n /= 2;
    } 
    return ans;
}
```
# 矩阵构造
> 构造时式子左边右边都有的不用变<br>

下边举一些栗子应该就十分好懂了<br>
### 一
Fibonacci数列**f[n]=f[n-1]+f[n-2],f[1]=f[2]=1**的第n项快速求法（不考虑高精度）<br>
<br>
解法：<br>
<br>
考虑1×2的矩阵 **{f[n-2],f[n-1]}**。根据Fibonacci数列的递推关系，我们可以通过乘以一个2×2的矩阵A，得到矩阵：**{f[n-1],f[n]}**。<br>
即：**{f[n-2],f[n-1]}*A = {f[n-1],f[n]}={f[n-1],f[n-1]+f[n-2]}**<br>
很容易构造出这个2×2矩阵A，即：
```cpp
0  1
1  1
```
则有 **{f[1],f[2]}×A＝{f[2],f[3]}** <br>
又因为矩阵乘法满足结合律，故有：<br>
**{f[1],f[2]}×A ^(n-1) ={f[n],f[n+1]}**<br>
这个矩阵的第一个元素f[n]即为所求。<br>
### 二
数列**f[n]=f[n-1]+f[n-2]+n+1,f[1]=f[2]=1**的第n项的快速求法（不考虑高精度）.<br>
<br>
解法：<br>
<br>
仿照前例，考虑1×4的矩阵 **{f[n-2],f[n-1],n,1}**，希望求得某4×4的矩阵A，使得此1×4的矩阵乘以A得到矩阵：**{f[n-1],f[n],n+1,1}**<br>
即：**{f[n-2],f[n-1],n,1}* A  = {f[n-1],f[n],n+1,1} = {f[n-1],f[n-1]+f[n-2]+n+1,n+1,1}**<br>
容易构造出这个4×4的矩阵A，即：
```cpp
0  1  0  0
1  1  0  0
0  1  1  0
0  1  1  1
```
故：**{f[1],f[2],3,1}* A^(n-1) = {f[n],f[n+1],n+2,1}**
### 三
数列f[n]=f[n-1]+f[n-2]+n+1,f[1]=f[2]=1的前n项和s[n]=f[1]+f[2]+……+f[n]的快速求法（不考虑高精度）.<br>
<br>
解法：<br>
<br>
考虑1×5的矩阵 **{f[n-2],f[n-1],s[n-2],n,1}**,<br>
我们需要找到一个5×5的矩阵A，使得它乘以A得到如下1×5的矩阵 **{f[n-1],f[n],s[n-1],n+1,1}**<br>
即：**{f[n-2],f[n-1],s[n-2],n,1}* A  = {f[n-1],f[n],s[n-1],n+1,1} = {f[n-1], f[n-1]+f[n-2]+n+1,s[n-2]+f[n-1],n+1,1}**<br>
容易构造出A为：
```cpp
0  1  0  0  0
1  1  1  0  0
0  0  1  0  0
0  1  0  1  0
0  1  0  1  1
```
故：**{f(1),f(2),s(1),3,1}* A^(n-1)  = {f(n),f(n+1),s(n),n+2,1}**<br>
### 四 
**f[n]=p*f[n-1]+q*f[n-2]+r*n+s**
可以构造矩阵A为：<br>
```cpp
0  q  0  0  0 
1  p  1  0  0 
0  0  1  0  0 
0  r  0  1  0 
0  s  0  1  1
```
更一般的，对于f[n]=Sigma(a[n-i]*f[n-i])+Poly(n)，其中0<i<=某常数c, Poly (n)表示n的多项式，我们依然可以构造类似的矩阵A来解决问题。
### 五
推广至一些相对复杂的栗子：<br>
* * *
比如 **f(1) = 1, f(2) = 1, f(n) = x*f(n-1) + y*f(n-2), sum(n) = f(0)^2 + ... + f(n)^2** 可构造如下
```cpp
1   0     0   0

1   x^2   1   x

0   y^2   0   0

0   2xy   0   y
```
* * *
比如 **f(1) = a, f(2) = b, f(n) = 2*f(n-2) + f(n-1) + n^4** <br>

易知 **(n+1)^4 = n^4 + 4*n^3 + 6*n^2 + 4*n + 1** <br>
可以构造如下
```cpp
|1   2   1   4   6   4   1|     |   f(n+1)   |     |   f(n+2)   |

|1   0   0   0   0   0   0|     |   f(n)     |     |   f(n+1)   |

|0   0   1   4   6   4   1|     |   (n+1)^4  |     |   (n+2)^4  |

|0   0   0   1   3   3   1|  *  |   (n+1)^3  |  =  |   (n+2)^3  |

|0   0   0   0   1   2   1|     |   (n+1)^2  |     |   (n+2)^2  |

|0   0   0   0   0   1   1|     |    n+1     |     |    n+2     |

|0   0   0   0   0   0   1|     |    1       |     |    1       |
```
* * *