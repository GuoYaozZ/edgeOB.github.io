---
layout:     post
title:      "ACM-Graph"
subtitle:   "图论"
date:       2019-06-01 09:00:00
author:     "programfiles"
header-img: "img/in-post/ACM.jpg"
tags:
    - ACM
---

* [无向图的割边与割点](#jump1)<br>
* [有向图的强连通分量](#jump2)<br>
* [点双连通分量与边双联通分量](#jump3)<br>
* [连通图中的重边问题](#jump4)<br>

<span id="jump1"></span> 
# 无向图的割边与割点

**定理：在无向图连通图G的dfs树中，非根结点u是G的割点当且仅当u存在一个子节点v，使得v及其所有的后代都没有反向边连回u的祖先（连回u不算连回祖先，所以也是割点）**<br><br>

![avatar](/img/blog-small/ACM-Graph1.png)<br>

如图，只要u有子节点v不存在连回祖先（橙色线），只存在紫色或者绿色的线，这时候u都是割点，去除u之后会导致连通块增多<br>
这样分析下来，我们就可以找到一种有一种很好的方法来解决这个问题，我们可以在dfs此图的时候记下 **dfn[u]每一个点访问的次序和low[u]每一个点和他的所有后代能连回的最早的祖先的pre值** 就可以了，即满足 **low[u] >= pre[u]** 的所有点，之后我们可以将桥作为割点的衍生产品:<br>

**定理：如果v的后代全部都只能连回v自己，即 low[u] > pre[u] 的情况下，只需要删除(u, v)一条边就可以使连通块增多，这个边就是桥**<br><br>

这种条件可能多次出现，所以我们在求割边和割点的时候，使用标记后统一输出的方式，而且，在dfs的时候不要漏掉判定 **v!=fa** 这个条件，也就是 fa->u 的反向边 u->fa 重走<br>

```cpp
割点 UVA315

void dfs(int u, int fa)
{
    int low[u] = pre[u] = ++dfs_block;
    int child = 0;
    for(int i = 0; i < G[u].size(); i++)
    {
        int v = G[u][i];
        if(!pre[v])
        {
            child++;
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] >= pre[u])
                iscut[u] = true;
        }
        else if(v != fa)
            low[u] = min(low[u], pre[v]);
    }
    if(fa < 0 && child == 1) iscut[u] = false;
}
割边 UVA976 注意976的排序wa疯了

struct node
{
    int fir, sec;
    bool operator < (node a) const {
        if(fir != a.fir) return fir < a.fir;
        return sec < a.sec;
    }
};
void dfs(int u, int fa)
{
    low[u] = pre[u] = ++dfs_block;
    for(int i = 0; i < G[u].size(); i++)
    {
        int v = G[u][i];
        if(!pre[v])
        {
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] > pre[u])
                all[co++] = node{u, v};
        }
        else if(v != fa)
            low[u] = min(low[u], low[v]);
    }
}
```
