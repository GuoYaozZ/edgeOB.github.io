---
layout:     post
title:      "ACM-Graph"
subtitle:   "图论"
date:       2019-06-01 09:00:00
author:     "programfiles"
header-img: "img/in-post/ACM.jpg"
tags:
    - ACM
---

* [无向图的割边与割点](#jump1)<br>
* [有向图的强连通分量](#jump2)<br>
* [点双连通分量与边双联通分量](#jump3)<br>
* [连通图中的重边问题](#jump4)<br>

<span id="jump1"></span> 
# 无向图的割边与割点

**定理：在无向图连通图G的dfs树中，非根结点u是G的割点当且仅当u存在一个子节点v，使得v及其所有的后代都没有反向边连回u的祖先（连回u不算连回祖先，所以也是割点）**<br><br>

![avatar](/img/blog-small/ACM-Graph1.png)<br>

如图，只要u有子节点v不存在连回祖先（橙色线），只存在紫色或者绿色的线，这时候u都是割点，去除u之后会导致连通块增多<br>
这样分析下来，我们就可以找到一种有一种很好的方法来解决这个问题，我们可以在dfs此图的时候记下 **dfn[u]每一个点访问的次序和low[u]每一个点和他的所有后代能连回的最早的祖先的pre值** 就可以了，即满足 **low[u] >= pre[u]** 的所有点，之后我们可以将桥作为割点的衍生产品:<br>

**定理：如果v的后代全部都只能连回v自己，即 low[u] > pre[u] 的情况下，只需要删除(u, v)一条边就可以使连通块增多，这个边就是桥**<br><br>

这种条件可能多次出现，所以我们在求割边和割点的时候，使用标记后统一输出的方式，而且，在dfs的时候不要漏掉判定 **v!=fa** 这个条件，也就是 fa->u 的反向边 u->fa 重走<br>

```cpp
割点 UVA315

void dfs(int u, int fa)
{
    int low[u] = pre[u] = ++dfs_block;
    int child = 0;
    for(int i = 0; i < G[u].size(); i++)
    {
        int v = G[u][i];
        if(!pre[v])
        {
            child++;
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] >= pre[u])
                iscut[u] = true;
        }
        else if(v != fa)
            low[u] = min(low[u], pre[v]);
    }
    if(fa < 0 && child == 1) iscut[u] = false;
}
割边 UVA976 注意976的排序wa疯了

struct node
{
    int fir, sec;
    bool operator < (node a) const {
        if(fir != a.fir) return fir < a.fir;
        return sec < a.sec;
    }
};
void dfs(int u, int fa)
{
    low[u] = pre[u] = ++dfs_block;
    for(int i = 0; i < G[u].size(); i++)
    {
        int v = G[u][i];
        if(!pre[v])
        {
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] > pre[u])
                all[co++] = node{u, v};
        }
        else if(v != fa)
            low[u] = min(low[u], low[v]);
    }
}

POJ3694也不错，有一个用不压缩路径的并查集来查找LCA的操作
```

<span id="jump2"></span> 
# 有向图的强连通分量

**定理：在有向图G中，如果两点可以互相到达，则称这两个点强连通； 如果有向图G的每两个点都强连通，那么我们将G称为一个强连通图； 有向图的极大强连通子图，称为强连通分量**<br><br>

tarjan，这是一种深度优先搜索寻找子树的方法，利用了dfs顺序产生的时间戳：每一个强连通子图都是一颗dfs产生的树，结点属于同一颗树也就是这些结点及其子结点能够访问到的最早的祖先相同<br>
在dfs的时候我们记录两个值， dfn[u] 和 low[u] ，分别表示当前结点是访问的第几个结点&当前结点及其子结点能访问到的最早的结点，如果 low[u] == pre[u] 就表明这个结点是这个树的根节点，辅助记录的操作用一个栈进行即可。网上讲解太多，这里不写了。。<br><br>
除了找强连通分量之外，我们一般还用强连通分量的算法进行缩点，就是将每一个强连通子图缩成一个点，建立一个新的图（树）<br>

[HDU4612](http://acm.hdu.edu.cn/showproblem.php?pid=4612)这里还有一个求树的直径的方法**先从任意一点P出发，找离它最远的点Q，再从点Q出发，找离它最远的点W，W到Q的距离就是是的直径**

```cpp
普通的强连通分量

void dfs(int u)
{
    low[u] = dfn[u] = ++dfs_block;
    S.push(u);
    for(int i = 0; i < G[u].size(); i++)
    {
        int v = G[u][i];
        if(!dfn[v])
        {
            dfs(v);
            low[u] = min(low[u], low[v]);
        }
        else if(!sccno[v])
            low[u] = min(low[u], low[v]);
    }
    if(low[u] == dfn[u])
    {
        ++scc_cnt;
        while(1)
        {
            int x = S.top(); S.pop();
            sccno[x] = scc_cnt;
            if(x == u) break;
        }
    }
}
```
```cpp
强连通分量缩点 HDU4612 代码的1和2是去重边的操作，每一步防止倒回fa的边即可

void dfs(int u, int fa)
{
    low[u] = dfn[u] = ++dfs_block;
    S.push(u);
1   bool flag = false;
    for(int i = 0; i < G[u].size(); i++)
    {
        int v = G[u][i];
        if(!dfn[v])
        {
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] > dfn[u])
                bridge++;
        }
        else if(v != fa || flag)
            low[u] = min(low[u], low[v]);
2       if(v == fa) flag = true;
    }
    if(low[u] == dfn[u])
    {
        ++scc_cnt;
        while(1)
        {
            int x = S.top(); S.pop();
            sccno[x] = scc_cnt;
            if(x == u) break;
        }
    }
}
void find_scc()
{
    init();
    for(int i = 1; i <= n; i++)
        if(!dfn[i]) dfs(i, -1);
}
void bfs(int s)
{
    queue<int> q;
    q.push(s);
    memset(vis, 0, sizeof(vis));
    vis[s] = 1; dis[s] = 0; last_node = s; ret = 0;
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        for(int i = 0; i < M[u].size(); i++)
        {
            int v = M[u][i];
            if(!vis[v])
            {
                vis[v] = 1;
                dis[v] = dis[u] + 1;
                if(dis[v] > ret)
                {
                    ret = dis[v];
                    last_node = v;
                }
                q.push(v);
            }
        }
    }
}
    bfs(1);
    bfs(last_node);
```



